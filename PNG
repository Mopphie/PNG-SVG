# -*- coding: utf-8 -*-
"""
Printable Content-Pipeline
--------------------------
â€¢ Wandelt PNG-Ausmalbilder in **echte SVG-Vektoren** Ã¼ber *potrace*
  (mit vorherigem Kontrast-Boost)
â€¢ Erzeugt A4-SVGs mit Rand (VerhÃ¤ltnis 210:297) inklusive Style-Block
â€¢ Erzeugt A4-Thumbnails (Breite fest, HÃ¶he A4-VerhÃ¤ltnis)
â€¢ PrÃ¼ft automatisch die QualitÃ¤t von SVG und Thumbnail
â€¢ Analysiert Motive & Tags mit **Gemini Flash 1.5**
â€¢ Ãœbersetzt Titel + Tags in 20 Sprachen (Cache in SQLite)
â€¢ LÃ¤dt SVG & Thumbnail nach Firebase Storage und legt Metadaten in Firestore ab

â€¼ VORAUSSETZUNGEN
    ðŸ–¼ï¸ Inkscape 1.2  (muss im System-PATH sein oder INKSCAPE_PATH in .env setzen)
    ðŸ–¼ï¸ potrace         (fÃ¼r die Bitmap-Vektorisierung, ebenfalls im PATH erwartet)
                         (Manuelle Anpassung der Inkscape-Export-Parameter ist optional)
    ðŸ”‘ Umgebungsvariablen (oder .env) â†’ GEMINI_API_KEY, FIREBASE_CREDENTIALS, FIREBASE_BUCKET
    ðŸ pip install -r requirements.txt
        (Liste der benÃ¶tigten Pakete fÃ¼r requirements.txt:
        google-generativeai
        firebase-admin
        pillow
        python-dotenv
        typer
        urllib3
        )
"""

from __future__ import annotations
import os, re, json, time, uuid, hashlib, tempfile, logging, threading, subprocess
import xml.etree.ElementTree as ET
import datetime as dt
from concurrent.futures import ThreadPoolExecutor, as_completed
from pathlib import Path
from typing import Tuple, Dict, List
import http.client
import socket
import urllib3.exceptions

from dotenv import load_dotenv
from PIL import Image, ImageOps
import google.generativeai as genai
from google.api_core import exceptions as google_api_exceptions
import firebase_admin
from firebase_admin import credentials, firestore, storage
import sqlite3

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load_dotenv()
GEMINI_API_KEY        = os.environ["GEMINI_API_KEY"]
FIREBASE_CREDENTIALS  = os.environ["FIREBASE_CREDENTIALS"]
FIREBASE_BUCKET       = os.environ["FIREBASE_BUCKET"]
INKSCAPE_PATH         = os.getenv("INKSCAPE_PATH", "inkscape")
POTRACE_PATH          = os.getenv("POTRACE_PATH", "potrace")
DEFAULT_DPI           = int(os.getenv("DEFAULT_DPI", "96"))
MAX_PARALLEL          = int(os.getenv("MAX_PARALLEL", "1"))
TARGET_THUMB_WIDTH_PX = int(os.getenv("THUMB_WIDTH", "350"))
TRACE_THRESHOLD       = os.getenv("TRACE_THRESHOLD", "0.5")
THUMB_RATIO_TOLERANCE = float(os.getenv("THUMB_RATIO_TOLERANCE", "0.05"))

A4_WIDTH_MM, A4_HEIGHT_MM = 210, 297

LANG_MAP: Dict[str, str] = {
    "Deutsch": "de", "Englisch": "en", "Spanisch": "es", "FranzÃ¶sisch": "fr",
    "Italienisch": "it", "Portugiesisch": "pt", "NiederlÃ¤ndisch": "nl", "Japanisch": "ja",
    "Koreanisch": "ko", "Mandarin": "zh", "Russisch": "ru", "Arabisch": "ar", "Hindi": "hi",
    "TÃ¼rkisch": "tr", "Polnisch": "pl", "Schwedisch": "sv", "Indonesisch": "id",
    "Vietnamesisch": "vi", "Tschechisch": "cs", "Ukrainisch": "uk"
}

BASE_IMAGE_DIRECTORY: Path = Path(r"C:\Users\Michi\Desktop\Ausmalbilder\Gemini neuer Designvorschlag\Technische Umsetzung\Bilder")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOGGING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s %(levelname)s | %(message)s",
                    handlers=[logging.FileHandler("processing.log", encoding="utf-8"),
                              logging.StreamHandler()])
log = logging.getLogger(__name__)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FIREBASE / GEMINI INITIALISIERUNG â”€â”€â”€â”€â”€â”€â”€â”€â”€
_db: firestore.Client | None = None
_bucket: storage.Bucket | None = None
MODEL_IMAGE = None
MODEL_TRANS = None

def _initialize_services() -> None:
    global _db, _bucket, MODEL_IMAGE, MODEL_TRANS
    if _db is not None:
        return

    try:
        if os.path.isfile(FIREBASE_CREDENTIALS):
            cred = credentials.Certificate(FIREBASE_CREDENTIALS)
            log.info("Firebase-Credentials als Dateipfad erkannt und geladen.")
        else:
            cred_dict = json.loads(FIREBASE_CREDENTIALS)
            cred = credentials.Certificate(cred_dict)
            log.info("Firebase-Credentials als JSON-String erkannt und geladen.")
    except (json.JSONDecodeError, ValueError) as e:
        log.error("FEHLER: FIREBASE_CREDENTIALS ist ungÃ¼ltig: %s", e)
        raise SystemExit("Firebase-Initialisierung fehlgeschlagen. Bitte FIREBASE_CREDENTIALS in .env Ã¼berprÃ¼fen.")

    firebase_admin.initialize_app(cred, {"storageBucket": FIREBASE_BUCKET})
    _db = firestore.client()
    _bucket = storage.bucket()

    genai.configure(api_key=GEMINI_API_KEY)
    MODEL_IMAGE = genai.GenerativeModel("gemini-1.5-flash")
    MODEL_TRANS = genai.GenerativeModel("gemini-1.5-flash")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HILFSKLASSEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class RateLimiter:
    def __init__(self, rpm: int = 60):
        self.rpm = rpm
        self._lock = threading.Lock()
        self._times: List[dt.datetime] = []

    def wait(self):
        with self._lock:
            now = dt.datetime.now()
            self._times = [t for t in self._times if (now - t).seconds < 60]
            if len(self._times) >= self.rpm:
                sleep_duration = 60 - (now - self._times[0]).seconds + 1
                log.warning("Rate-Limit erreicht â€“ warte %.1fs", sleep_duration)
                time.sleep(sleep_duration)
            self._times.append(dt.datetime.now())

rate = RateLimiter()

class TranslationCache:
    def __init__(self, path: str = "translation_cache.db"):
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self.conn.execute("""CREATE TABLE IF NOT EXISTS tcache (
                                orig TEXT, lang TEXT, trans TEXT,
                                PRIMARY KEY(orig, lang))""")
        self.lock = threading.Lock()

    def get(self, text: str, lang: str):
        with self.lock:
            cur = self.conn.execute("SELECT trans FROM tcache WHERE orig=? AND lang=?", (text, lang))
            row = cur.fetchone()
            return row[0] if row else None

    def set(self, text: str, lang: str, trans: str):
        with self.lock:
            self.conn.execute("INSERT OR REPLACE INTO tcache VALUES (?,?,?)", (text, lang, trans))
            self.conn.commit()

cache = TranslationCache()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GEMINI CALLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def smart_retry(max_retry: int = 4):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_retry):
                try:
                    rate.wait()
                    return func(*args, **kwargs)
                except (
                    google_api_exceptions.ResourceExhausted,
                    google_api_exceptions.InternalServerError,
                    google_api_exceptions.ServiceUnavailable,
                    http.client.RemoteDisconnected,
                    socket.timeout,
                    TimeoutError,
                    urllib3.exceptions.ProtocolError
                ) as e:
                    log.warning("%s fehlgeschlagen (%s). Versuch %d/%d", func.__name__, e, attempt+1, max_retry)
                    time.sleep(2 ** attempt)
                except Exception as e:
                    log.error("%s unerwarteter Fehler: %s.", func.__name__, e, exc_info=True)
                    raise
            raise RuntimeError(f"{func.__name__} permanent fehlgeschlagen nach {max_retry} Versuchen.")
        return wrapper
    return decorator

@smart_retry()
def analyze_image(png_path: Path) -> Tuple[str, List[str]]:
    with Image.open(png_path) as img:
        prompt = (
            "Analysiere das gezeigte Ausmalbild. Antworte **nur** mit\n"
            "MOTIV: <kurze Phrase>\nTAGS: <comma sep tags>"
        )
        resp = MODEL_IMAGE.generate_content([prompt, img])
        text_content = resp.text.strip()
        motif_match = re.search(r"MOTIV:(.*)", text_content, re.I)
        tags_match = re.search(r"TAGS:(.*)", text_content, re.I)
        motif = motif_match.group(1).strip() if motif_match else "Unbekanntes Motiv"
        tags = [t.strip() for t in tags_match.group(1).split(',') if t.strip()] if tags_match else []
        if not motif or not tags:
            log.warning("Gemini Analyse fÃ¼r %s unvollstÃ¤ndig: Motiv='%s', Tags='%s'. Antwort: %s", png_path.name, motif, tags, text_content)
        return motif, tags

@smart_retry()
def translate(text: str, lang_name: str, lang_code: str):
    cached = cache.get(text, lang_code)
    if cached:
        return cached
    prompt = f"Ãœbersetze folgenden Text ins {lang_name}. Gib **nur** die Ãœbersetzung zurÃ¼ck.\n{text}"
    resp = MODEL_TRANS.generate_content(prompt)
    trans = resp.text.strip()
    cache.set(text, lang_code, trans)
    return trans

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INKSCAPE-HILFSFUNKTIONEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def check_inkscape():
    log.info("PrÃ¼fe Inkscape 1.2-KompatibilitÃ¤t...")
    try:
        result = subprocess.run(
            [INKSCAPE_PATH, "--version"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=10,
            text=True
        )
        version_output = result.stdout
        if "1.2" not in version_output:
            log.warning("Inkscape-Version ist nicht 1.2: %s. Skript ist fÃ¼r 1.2 optimiert.", version_output)
    except FileNotFoundError:
        log.error("FEHLER: Inkscape nicht gefunden. Installiere Inkscape 1.2 oder setze INKSCAPE_PATH in .env.")
        raise SystemExit("Inkscape nicht gefunden.")
    except subprocess.CalledProcessError as e:
        log.error("FEHLER: Inkscape --version fehlgeschlagen: %s", e.stderr)
        raise SystemExit("Inkscape --version fehlgeschlagen.")

check_inkscape()

def check_potrace():
    try:
        subprocess.run(
            [POTRACE_PATH, "--version"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=10,
        )
    except FileNotFoundError:
        log.error("FEHLER: potrace nicht gefunden. Installiere es oder setze POTRACE_PATH.")
        raise SystemExit("potrace nicht gefunden.")
    except subprocess.CalledProcessError as e:
        log.error("FEHLER: potrace --version fehlgeschlagen: %s", e.stderr.decode())
        raise SystemExit("potrace --version fehlgeschlagen.")

check_potrace()

def _ensure_black_fill_and_stroke(svg_content: str) -> str:
    def _replace_style(match: re.Match) -> str:
        style = match.group(1)
        pairs = [s.strip() for s in style.split(";") if ":" in s]
        style_dict = {k.strip(): v.strip() for k, v in (p.split(":", 1) for p in pairs)}
        style_dict["fill"] = "#000000"
        style_dict["stroke"] = "none"
        return 'style="' + ";".join(f"{k}:{v}" for k, v in style_dict.items()) + '"'

    svg_content = re.sub(r'style="([^"]*)"', _replace_style, svg_content)
    svg_content = re.sub(r'fill="[^"]*"', 'fill="#000000"', svg_content)
    svg_content = re.sub(r'stroke="[^"]*"', 'stroke="none"', svg_content)
    log.info("Erzwungene schwarze FÃ¼llung und keine Striche in SVG.")
    return svg_content

def preprocess_png(src: Path, dest: Path) -> None:
    img = Image.open(src).convert("L")
    img = ImageOps.autocontrast(img)
    bbox = ImageOps.invert(img).getbbox()
    if bbox:
        img = img.crop(bbox)
    img.save(dest)

def trace_png_to_svg(png_path: Path, svg_out: Path):
    log.info("Vektorisierung von %s mit potrace...", png_path.name)
    with tempfile.TemporaryDirectory() as tdir:
        prep = Path(tdir) / "pre.png"
        preprocess_png(png_path, prep)
        pgm = Path(tdir) / "pre.pgm"
        Image.open(prep).convert("L").save(pgm)
        cmd = [
            POTRACE_PATH,
            str(pgm),
            "-s",
            "-o",
            str(svg_out),
            "-k",
            str(TRACE_THRESHOLD),
        ]
        try:
            result = subprocess.run(
                cmd,
                check=True,
                capture_output=True,
                text=True,
                timeout=120,
            )
            if not svg_out.exists() or svg_out.stat().st_size == 0:
                log.error("potrace hat keine SVG-Datei erstellt oder sie ist leer: %s. stdout: %s, stderr: %s",
                          svg_out, result.stdout, result.stderr)
                raise RuntimeError(f"potrace hat keine SVG-Datei erstellt oder sie ist leer: {svg_out}")
        except subprocess.CalledProcessError as e:
            log.error("potrace Vektorisierung fehlgeschlagen fÃ¼r %s: %s (stdout: %s, stderr: %s)",
                      png_path.name, e, e.stdout, e.stderr)
            raise
    log.info("Vektorisierung erfolgreich: %s", svg_out.name)

def create_a4_canvas(svg_in: Path, svg_a4_out: Path):
    log.info("A4-Canvas fÃ¼r %s erstellen...", svg_in.name)
    dpi = DEFAULT_DPI
    a4_w_px = int(A4_WIDTH_MM * dpi / 25.4)
    a4_h_px = int(A4_HEIGHT_MM * dpi / 25.4)
    scale_factor = 0.9
    translate_x = (a4_w_px * (1 - scale_factor)) / 2
    translate_y = (a4_h_px * (1 - scale_factor)) / 2
    style_block = (
        "<style>path,rect,circle,ellipse,polygon,polyline,line{fill:#000000;stroke:none}</style>"
    )
    template = (
        f"""<?xml version="1.0" encoding="UTF-8"?>
<svg width="{a4_w_px}px" height="{a4_h_px}px"
     viewBox="0 0 {a4_w_px} {a4_h_px}"
     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  {style_block}
  <g transform="translate({int(translate_x)},{int(translate_y)}) scale({scale_factor})">
    {{content}}
  </g>
</svg>"""
    )
    full_raw_svg_content = Path(svg_in).read_text(encoding="utf-8")
    match = re.search(r"<svg[^>]*?>(.*?)</svg>", full_raw_svg_content, re.DOTALL)
    if match:
        inner_svg_content = match.group(1).strip()
    else:
        log.error(f"FEHLER: Konnte inneren SVG-Inhalt aus {svg_in.name} nicht extrahieren.")
        inner_svg_content = full_raw_svg_content
    inner_svg_content = _ensure_black_fill_and_stroke(inner_svg_content)
    with open(svg_a4_out, "w", encoding="utf-8") as fh:
        fh.write(template.replace("{content}", inner_svg_content))
    log.info("A4-Canvas erstellt: %s", svg_a4_out.name)

def create_thumbnail(svg_path: Path, thumb_out: Path):
    log.info("Thumbnail fÃ¼r %s erstellen...", svg_path.name)
    cmd = [INKSCAPE_PATH, str(svg_path),
           "--export-type=png",
           f"--export-width={TARGET_THUMB_WIDTH_PX}",
           "--export-area-page",
           "--export-background=white",
           "--export-filename", str(thumb_out)]
    try:
        result = subprocess.run(
            cmd,
            check=True,
            capture_output=True,
            text=True,
            timeout=60,  # Reduced timeout for Inkscape 1.2
        )
        if not thumb_out.exists() or thumb_out.stat().st_size == 0:
            log.error("Inkscape hat keine Thumbnail-Datei erstellt oder sie ist leer: %s. stdout: %s, stderr: %s",
                      thumb_out, result.stdout, result.stderr)
            raise RuntimeError(f"Inkscape hat keine Thumbnail-Datei erstellt oder sie ist leer: {thumb_out}")
        img = Image.open(thumb_out)
        img = ImageOps.autocontrast(img.convert("L")).convert("RGB")
        img.save(thumb_out, optimize=True, compress_level=9)
    except subprocess.CalledProcessError as e:
        log.error("Inkscape Thumbnail-Erstellung fehlgeschlagen fÃ¼r %s: %s (stdout: %s, stderr: %s)",
                  svg_path.name, e, e.stdout, e.stderr)
        raise
    log.info("Thumbnail erfolgreich: %s", thumb_out.name)

def _validate_svg(svg_path: Path) -> bool:
    try:
        tree = ET.parse(svg_path)
        root = tree.getroot()
    except ET.ParseError as e:
        log.error("SVG-Parsing-Fehler: %s", e)
        return False
    expected_w = int(A4_WIDTH_MM * DEFAULT_DPI / 25.4)
    expected_h = int(A4_HEIGHT_MM * DEFAULT_DPI / 25.4)
    width = root.get("width", "0").replace("px", "")
    height = root.get("height", "0").replace("px", "")
    try:
        if int(float(width)) != expected_w or int(float(height)) != expected_h:
            log.error("SVG hat unerwartete Dimensionen: %sx%s", width, height)
            return False
    except ValueError:
        log.error("SVG width/height nicht numerisch: %s/%s", width, height)
        return False
    target_tags = {"path", "rect", "circle", "ellipse", "polygon", "polyline", "line"}
    if not any(elem.tag.split('}')[-1] in target_tags for elem in root.iter()):
        log.error("SVG enthÃ¤lt keine Vektorelemente")
        return False
    svg_content = Path(svg_path).read_text(encoding="utf-8")
    if "fill:#000" not in svg_content and "fill:#000000" not in svg_content:
        log.error("SVG nicht schwarz gefÃ¤rbt")
        return False
    for elem in root.iter():
        if elem.get('fill') and elem.get('fill') != '#000000':
            log.error("SVG enthÃ¤lt nicht-schwarze FÃ¼llungen: %s", elem.get('fill'))
            return False
        if elem.get('stroke') and elem.get('stroke') != 'none':
            log.error("SVG enthÃ¤lt Striche: %s", elem.get('stroke'))
            return False
    return True

def _validate_thumbnail(png_path: Path) -> bool:
    try:
        img = Image.open(png_path)
    except Exception as e:
        log.error("Thumbnail konnte nicht geÃ¶ffnet werden: %s", e)
        return False
    if img.width != TARGET_THUMB_WIDTH_PX:
        log.error("Thumbnail-Breite falsch: %d", img.width)
        return False
    expected_ratio = A4_HEIGHT_MM / A4_WIDTH_MM
    actual_ratio = img.height / img.width
    if abs(actual_ratio - expected_ratio) > THUMB_RATIO_TOLERANCE:
        log.error("Thumbnail-SeitenverhÃ¤ltnis abweichend: %.3f", actual_ratio)
        return False
    lo, hi = img.convert("L").getextrema()
    if hi - lo < 20:
        log.error("Thumbnail-Kontrast zu niedrig")
        return False
    return True

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STORAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def upload(local: Path, blob_name: str, mime: str) -> str:
    log.info("Hochladen von %s zu Firebase Storage (%s)...", local.name, blob_name)
    blob = _bucket.blob(blob_name)
    blob.upload_from_filename(str(local), content_type=mime)
    log.info("Hochladen erfolgreich: %s", blob_name)
    return blob.name

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPER FUNKTIONEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def sha256(path: Path) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WORKER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def process_png(png_path: Path, main_cat: str, sub_cat: str):
    log.info("Starte Verarbeitung von Bild: %s (Kategorie: %s/%s)", png_path.name, main_cat, sub_cat)
    _initialize_services()
    file_hash = sha256(png_path)
    if _db.collection("processed_files").document(file_hash).get().exists:
        log.info("%s wurde bereits verarbeitet (Hash: %s) â€“ Ã¼bersprungen.", png_path.name, file_hash)
        return "skipped"
    try:
        Image.open(png_path).verify()
    except Exception as e:
        raise ValueError(f"UngÃ¼ltige oder beschÃ¤digte PNG-Datei: {e}")
    log.info("Schritt 1: Starte Gemini-Analyse fÃ¼r %s...", png_path.name)
    motif_de, tags_de = analyze_image(png_path)
    log.info("Analyse abgeschlossen: Motiv='%s', Tags='%s'", motif_de, tags_de)
    log.info("Schritt 2: Ãœbersetze Metadaten...")
    translations = {}
    for ln, lc in LANG_MAP.items():
        if lc == "de":
            translations[lc] = dict(title=motif_de, tags=tags_de)
        else:
            translated_title = translate(motif_de, ln, lc)
            translated_tags = [translate(t, ln, lc) for t in tags_de]
            translations[lc] = dict(title=translated_title, tags=translated_tags)
    log.info("Ãœbersetzungen abgeschlossen.")
    log.info("Schritt 3: Erstelle SVG und Thumbnail mit Inkscape...")
    with tempfile.TemporaryDirectory() as tmp:
        tmp_path = Path(tmp)
        svg_raw = tmp_path / "raw.svg"
        svg_a4 = tmp_path / "a4.svg"
        thumb_png = tmp_path / "thumb.png"
        trace_png_to_svg(png_path, svg_raw)
        create_a4_canvas(svg_raw, svg_a4)
        create_thumbnail(svg_a4, thumb_png)
        if not (_validate_svg(svg_a4) and _validate_thumbnail(thumb_png)):
            raise ValueError("QualitÃ¤tsprÃ¼fung fehlgeschlagen")
        slug = re.sub(r"[^a-z0-9]+", "-", motif_de.lower())
        slug = slug[:50].strip('-') or "bild"
        slug += "-" + uuid.uuid4().hex[:6]
        svg_blob_name = f"{main_cat}/{sub_cat}/{slug}.svg"
        png_blob_name = f"{main_cat}/{sub_cat}/{slug}.png"
        log.info("Schritt 4: Lade Dateien zu Firebase Storage hoch...")
        upload(svg_a4, svg_blob_name, "image/svg+xml")
        upload(thumb_png, png_blob_name, "image/png")
        log.info("Uploads abgeschlossen.")
    log.info("Schritt 5: Speichere Metadaten in Firestore...")
    doc_data = {
        "title": {lc: d["title"] for lc, d in translations.items()},
        "tags": {lc: d["tags"] for lc, d in translations.items()},
        "mainCategory": main_cat,
        "subCategory": sub_cat,
        "pathSvg": svg_blob_name,
        "pathPng": png_blob_name,
        "createdAt": firestore.SERVER_TIMESTAMP,
        "hash": file_hash,
        "isPremium": False,
    }
    _db.collection("images").add(doc_data)
    _db.collection("processed_files").document(file_hash).set({"ts": firestore.SERVER_TIMESTAMP})
    log.info("Metadaten in Firestore gespeichert.")
    png_path.unlink(missing_ok=True)
    log.info("Bild %s vollstÃ¤ndig verarbeitet und hochgeladen. Original-PNG gelÃ¶scht.", png_path.name)
    return "processed"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def main():
    log.info("Starte Bildverarbeitung von Basis-Verzeichnis: %s", BASE_IMAGE_DIRECTORY)
    files_to_process: List[Tuple[Path, str, str]] = []
    if not BASE_IMAGE_DIRECTORY.is_dir():
        log.error("FEHLER: Basis-Ordner nicht gefunden: %s", BASE_IMAGE_DIRECTORY)
        return
    for folder in BASE_IMAGE_DIRECTORY.iterdir():
        if folder.is_dir():
            parts = folder.name.split("_")
            main_cat = parts[0].strip() if parts else ""
            sub_cat = parts[1].strip() if len(parts) >= 2 else "Allgemein"
            if not main_cat:
                log.warning("UngÃ¼ltiger Ordnername '%s'. Ãœbersprungen.", folder.name)
                continue
            png_files_in_folder = list(folder.glob("*.png"))
            if not png_files_in_folder:
                log.info("Keine PNGs in Ordner '%s'.", folder.name)
                continue
            for p in png_files_in_folder:
                files_to_process.append((p, main_cat, sub_cat))
            log.info("Gefunden: %d PNGs in Ordner '%s' (Kategorie: %s/%s)", len(png_files_in_folder), folder.name, main_cat, sub_cat)
        else:
            log.info("'%s' ist kein Verzeichnis. Ãœbersprungen.", folder.name)
    if not files_to_process:
        log.info("Keine PNGs gefunden. Beende.")
        return
    log.info("Beginne Verarbeitung von %d Bildern mit %d parallelen Prozessen...", len(files_to_process), MAX_PARALLEL)
    stats = {"processed": 0, "skipped": 0, "failed": 0}
    with ThreadPoolExecutor(max_workers=MAX_PARALLEL) as pool:
        futures = {pool.submit(process_png, p, mc, sc): p.name for p, mc, sc in files_to_process}
        for fut in as_completed(futures):
            png_name = futures[fut]
            try:
                res = fut.result()
                stats[res] += 1
                log.info("Status fÃ¼r %s: %s", png_name, res.upper())
            except Exception as e:
                stats["failed"] += 1
                log.error("Unerwarteter Fehler fÃ¼r %s: %s", png_name, e)
    log.info("VERARBEITUNG ABGESCHLOSSEN â€“ Statistik: %s", stats)


def local_test(png_path: Path) -> None:
    """Run the conversion pipeline locally without Firebase/Gemini."""
    log.info("Lokaler Testlauf fÃ¼r %s", png_path.name)
    svg_raw = Path("local_raw.svg")
    svg_a4 = Path("local_a4.svg")
    thumb = Path("local_thumb.png")
    trace_png_to_svg(png_path, svg_raw)
    create_a4_canvas(svg_raw, svg_a4)
    create_thumbnail(svg_a4, thumb)
    log.info("SVG valide: %s", _validate_svg(svg_a4))
    log.info("Thumbnail valide: %s", _validate_thumbnail(thumb))


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        local_test(Path(sys.argv[1]))
    else:
        main()
